# Automaton Lab.

## 問題文

Automaton Lab.で将来予測のお手伝いをしましょう

```
nc automaton.mis.wanictf.org 50020
```

reference: https://en.wikipedia.org/wiki/Rule_30

## フラグ

`FLAG{W3_4w4rd_y0u_d0c70r473_1n_Fu7ur3_S1gh7}`
## 解法

2番目までは愚直なシミュレーションでも解くことができますが、3番目を解くためには工夫が必要です。

このオートマトンは10個しかセルがないため、考えうる状態数はたかだか1024です。このことを利用します。

まず、1024の状態それぞれについて、1世代進めた後のオートマトンの状態を求めます。これを記録しておきます。
何世代か進めた後のオートマトンの状態をシミュレーションを行うことなく知りたいとき、セルの全状態について遷移を求めているため、この記録を順番にたどれば良いということが分かると思います。

ではここで、k世代たどった分についてまとめておくことにします。このとき、私たちは1世代先、k世代先の2つについて全状態の遷移先を知っていることになります。この場合、n世代先のオートマトンの状態はk世代先への遷移をfloor(n/k)回行った後、1世代先への遷移をn%k回行うことで求められます。まとめる操作を適切に繰り返すことで、さらに計算回数を抑えることもできます。

ここで2の指数表記について考えます。2進数の定義から、すべての正の整数はすべての2の累乗を0回または1回だけ加算した和で表すことができます。

例えば、10(2進数で 00001010) = 2^3 + 2^1, 255(2進数で 11111111) = 2^7 + 2^6 + 2^5 + ... + 2^1 + 2^0 です。また、2^(n+1)世代後の遷移 = 2^n世代後の遷移(2^n世代後の遷移)です。

したがって、

- 全状態について、次の次の遷移先を求める
- （必要ならば）現在の状態を遷移先に変化させる

の2つの操作を順番に行っていくことで、n世代先の状態を効率よく求めることができます。計算量はO(2^S * logN)です（Sはオートマトンのセルの数、Nは求めたい世代）。

“必要ならば”の部分ですが、これは2進数表記においてbitが1であることと同値なので、bitwise andによって調べることができます。

このテクニックのことをダブリングと言います。

### 余談

この方法で無事解答を求めることができるのですが、最後のケースでは手元の環境で5秒ほどの計算時間が必要でした。しかし、問題サーバーで問題の生成に使っている手法、およびWaniHackase内部でこの問題のテストを担当した人の解法はダブリングではありません。最悪計算量はダブリングより悪いですが、実用的にはダブリングより高速な方法を使って問題を生成しています。問題のソースコードsrc/automaton.pyには両方の実装を載せているので、興味がある方はぜひご覧ください（というか、こちらで解いた方が多いのでは？）。

## 参考

http://satanic0258.hatenablog.com/entry/2017/02/23/222647
